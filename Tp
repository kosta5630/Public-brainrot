local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local camera = workspace.CurrentCamera
local gui = Instance.new("ScreenGui", player:WaitForChild("PlayerGui"))
gui.Name = "DeliveryHitboxUI"
gui.ResetOnSpawn = false

local selectedHitbox = nil
local buttons = {}

-- Move player to sky and walk toward hitbox while in air, then drop smoothly
local function skyWalkTo(hitbox)
	local character = player.Character or player.CharacterAdded:Wait()
	local hrp = character:WaitForChild("HumanoidRootPart")
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid or not hrp then return end

	local oldAnchored = hrp.Anchored
	hrp.Anchored = true

	-- Go to sky level (Y=50)
	local skyStartPos = Vector3.new(hrp.Position.X, 50, hrp.Position.Z)
	hrp.CFrame = CFrame.new(skyStartPos)

	local targetSkyPos = Vector3.new(hitbox.Position.X, 50, hitbox.Position.Z)
	local speed = 50 -- studs per second

	local conn
	conn = RunService.Heartbeat:Connect(function(dt)
		if not character or not hrp or not humanoid or not hitbox then
			conn:Disconnect()
			hrp.Anchored = oldAnchored
			return
		end

		local currentPos = hrp.Position
		local horizontalTarget = Vector3.new(targetSkyPos.X, currentPos.Y, targetSkyPos.Z)
		local horizontalDir = (horizontalTarget - currentPos)
		local horizontalDist = horizontalDir.Magnitude

		if horizontalDist > 1 then
			-- Move horizontally toward targetSkyPos
			local moveDelta = math.min(speed * dt, horizontalDist)
			hrp.CFrame = hrp.CFrame + horizontalDir.Unit * moveDelta
		else
			-- Horizontal reached, now drop down smoothly
			conn:Disconnect()

			local dropStartY = hrp.Position.Y
			local dropEndY = hitbox.Position.Y + 5
			local dropDuration = (dropStartY - dropEndY) / speed
			local elapsed = 0

			-- New connection to handle drop
			local dropConn
			dropConn = RunService.Heartbeat:Connect(function(dropDt)
				elapsed = elapsed + dropDt
				local alpha = math.clamp(elapsed / dropDuration, 0, 1)
				local newY = dropStartY - alpha * (dropStartY - dropEndY)
				hrp.CFrame = CFrame.new(hrp.Position.X, newY, hrp.Position.Z)

				if alpha >= 1 then
					dropConn:Disconnect()
					hrp.Anchored = oldAnchored
				end
			end)
		end
	end)
end

-- Create button for each DeliveryHitbox
local function createButton(hitbox)
	local button = Instance.new("TextButton")
	button.Size = UDim2.new(0, 40, 0, 40)
	button.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
	button.BackgroundTransparency = 0.2
	button.Text = ""
	button.BorderSizePixel = 0
	button.AnchorPoint = Vector2.new(0.5, 0.5)
	button.AutoButtonColor = true
	button.ClipsDescendants = true
	button.Parent = gui
	button.ZIndex = 10
	button.Name = "DeliveryButton"

	local corner = Instance.new("UICorner", button)
	corner.CornerRadius = UDim.new(1, 0)

	button.MouseButton1Click:Connect(function()
		selectedHitbox = hitbox
		for _, b in pairs(buttons) do
			b.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
		end
		button.BackgroundColor3 = Color3.fromRGB(100, 255, 100)
	end)

	RunService.RenderStepped:Connect(function()
		if hitbox and hitbox:IsDescendantOf(workspace) then
			local screenPos, onScreen = camera:WorldToViewportPoint(hitbox.Position + Vector3.new(0, 3, 0))
			button.Visible = onScreen
			if onScreen then
				button.Position = UDim2.new(0, screenPos.X, 0, screenPos.Y)
			end
		else
			button.Visible = false
		end
	end)

	table.insert(buttons, button)
end

-- Initialize buttons for all DeliveryHitboxes
for _, obj in pairs(workspace:GetDescendants()) do
	if obj:IsA("BasePart") and obj.Name == "DeliveryHitbox" then
		createButton(obj)
	end
end

-- Handle key press for teleport
UserInputService.InputBegan:Connect(function(input, processed)
	if processed then return end
	if input.KeyCode == Enum.KeyCode.T and selectedHitbox then
		skyWalkTo(selectedHitbox)
	end
end)
